# REF: https://github.com/dfeich/org-babel-examples/blob/master/beamer/beamer-example.org
#+TITLE:     Linear Systems: Matrices, eigen-values, ... 
#+SUBTITLE:  Herramientas de Modelación - Maestría en Gestión y Diseño de Procesos
#+AUTHOR:    William Oquendo, woquendo@gmail.com
#+EMAIL:     woquendo@gmail.com
#+DATE:

#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   num:t toc:t ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS:   tex:t d:nil todo:t pri:nil tags:nil
#+OPTIONS:   timestamp:t

# started this on 2010-03-30 Tue

# this allows defining headlines to be exported/not be exported
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

# By default I do not want that source code blocks are evaluated on export. Usually
# I want to evaluate them interactively and retain the original results.
#+PROPERTY: header-args :eval export

* Beamer configuration                                             :noexport:
** Basic
# this triggers loading the beamer menu (C-c C-b) when the file is read
#+startup: beamer

#+LaTeX_CLASS: beamer

#    LATEX CLASS OPTIONS
# [bigger]
# [presentation]
# [handout] : print handouts, i.e. slides with overlays will be printed with
#   all overlays turned on (no animations).
# [notes=show] : show notes in the generated output (note pages follow the real page)
# [notes=only] : only render the nodes pages

# this setting affects whether the initial PSI picture correctly fills
# the title page, since it scales the title text. One can also use the
# notes=show or notes=only options to produce notes pages in the output.
# #+LaTeX_CLASS_OPTIONS: [t,10pt,notes=show]

#+LaTeX_CLASS_OPTIONS: [xcolor=svgnames,t,10pt,allowframebreaks]


#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)

# export second level headings as beamer frames. All headlines below
# the org-beamer-frame-level (i.e. below H value in OPTIONS), are
# exported as blocks
#+OPTIONS: H:2

** Beamer Theme Definition
# #+BEAMER_THEME: Madrid 
# #+BEAMER_THEME: Darmstadt 
# #+BEAMER_THEME: default 
#+BEAMER_THEME: [sectionpage=progressbar,subsectionpage=progressbar,numbering=counter,progressbar=foot,block=transparent]metropolis 

# Note: custom style files can be placed centrally in the user specific directory
# ~/texmf/tex. This will be searched recursively, so substructures are possible.
# q.v. http://tex.stackexchange.com/questions/1137/where-do-i-place-my-own-sty-or-cls-files-to-make-them-available-to-all-my-te

# One could also fine tune a number of theme settings instead of specifying the full theme
# #+BEAMER_COLOR_THEME: [named=Brown]structure
# #+BEAMER_FONT_THEME: [onlysmall]structurebold
# #+BEAMER_INNER_THEME:
# #+BEAMER_OUTER_THEME: miniframes [subsection=false]
# #+LATEX_CLASS: beamer


** changes to BeginSection for TOC and navigation
#+BEAMER_HEADER: \AtBeginSection[]{

# This line inserts a table of contents with the current section highlighted at
# the beginning of each section
#+BEAMER_HEADER: \begin{frame}<beamer>\frametitle{Topic}\tableofcontents[currentsection,currentsubsection]\end{frame}

# In order to have the miniframes/smoothbars navigation bullets even though we do not use subsections 
# q.v. https://tex.stackexchange.com/questions/2072/beamer-navigation-circles-without-subsections/2078#2078
# #+BEAMER_HEADER: \subsection{}
#+BEAMER_HEADER: }

** misc configuration
# I want to define a style for hyperlinks
#+BEAMER_HEADER: \hypersetup{colorlinks=true, linkcolor=blue}

# this can be used to define the transparency of the covered layers
#+BEAMER: \setbeamercovered{transparent=30}


** Some remarks on options
   - [[info:org#Export%20settings][info:org#Export settings]]
   - The H:2 setting in the options line is important for setting the
     Beamer frame level. Headlines will become frames when their level
     is equal to =org-beamer-frame-level=.
   - ^:{} interpret abc_{subs} as subscript, but not abc_subs
   - num:t configures whether to use section numbers. If set to a number
     only headlines of this level or above will be numbered
   - ::t defines that lines starting with ":" will use fixed width font
   - |:t include tables in export
   - -:t Non-nil means interpret "\-", "--" and "---" for export.
   - f:t include footnotes
   - *:t Non-nil means interpret
     : *word*, /word/, _word_ and +word+.
   - <:t toggle inclusion of timestamps
   - timestamp:t include a document creation timestamp into the exported file
   - todo:t include exporting of todo keywords
   - d:nil do not export org heading drawers
   - tags:nil do not export headline tags

** Metropolis theme (specific)
# #+BEAMER: \defbeamertemplate{footline}{plain}{%
# #+BEAMER: \begin{beamercolorbox}[wd=\textwidth, sep=3ex]{footline}%
# #+BEAMER: \usebeamerfont{page number in head/foot} PPPP%
# #+BEAMER: \usebeamertemplate*{frame footer} SSSS
# #+BEAMER: \hfill%
# #+BEAMER: \usebeamertemplate*{frame numbering}
# # #+BEAMER: EXAMPLE
# #+BEAMER: \end{beamercolorbox}%
# #+BEAMER: }   
** Minted specific
#+LATEX_HEADER: \newsavebox{\mybox}

** math fonts
#+LATEX_HEADER: \usefonttheme[onlymath]{serif}

* Configuration for org-reftex and bibliography                    :noexport:
# #+LATEX_HEADER: \bibliography{biblio.bib}

* Linear Systems and Matrices
**  Example : Bungee-jumping family plan \cite{chapra2012AppliedNumericalMethods} :B_fullframe:
   :PROPERTIES:
   # :BEAMER_OPT: standout,label=
   :BEAMER_env: fullframe
   :END:
   #+LATEX: \vfill
   #+BEGIN_CENTER
   #+attr_latex: :width 1.0\textwidth :float t :placement [H] :center
   [[file:fig/bungee-family-01.pdf]]
   #+END_CENTER
   #+LATEX: \vfill
   
**  Example : System of equations                               :B_fullframe:
   :PROPERTIES:
   # :BEAMER_OPT: standout,label=
   :BEAMER_act: [<+->]
   :BEAMER_env: fullframe
   :END:
   #+LATEX: \vfill
   #+BEGIN_CENTER
   #+Beamer: \only<1->{
   The second Newton law produces: 
   #+attr_latex: :width 0.5\textwidth :float t :placement [H] :center
   [[file:fig/bungee-family-equ-00.pdf]]
   #+END_CENTER
   #+LATEX: \vfill
   #+BEGIN_CENTER
   #+ATTR_BEAMER: :overlay +-
   #+Beamer: }\only<2->{
   And for a system in equilibrium, we get:
   #+attr_latex: :width 0.7\textwidth :float t :placement [H] :center
   [[file:fig/bungee-family-equ.pdf]]
   #+Beamer: }
   #+END_CENTER
   #+LATEX: \vfill

** A matrix                                                     :B_fullframe:
   :PROPERTIES:
   # :BEAMER_OPT: standout,label=
   :BEAMER_act: [<+->]
   :BEAMER_env: fullframe
   :END:
   #+attr_latex: :width 0.9\textwidth :float t :placement [H] :center
   [[file:fig/matrix-base.pdf]]

** Special cases                                 
   :PROPERTIES:
   #:BEAMER_act: [<+->]
   #:BEAMER_opt: allowframebreaks,label=
   #:BEAMER_col: 0.5\textwidth
   :END:
***                                                          
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
   - <1-> A symmetric matrix :\\
     [[file:fig/matrix-sym.pdf]]
   - <2-> A diagonal matrix :\\
     [[file:fig/matrix-diag.pdf]]
   - <3-> Identity matrix : \\
     [[file:fig/matrix-iden.pdf]]
***                                              
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
   - <4-> Upper triangular :\\
     [[file:fig/matrix-upper.pdf]]
   - <5-> Lower triangular :\\
     [[file:fig/matrix-lower.pdf]]
   - <6-> Banded :\\
     [[file:fig/matrix-banded.pdf]]

** Matrix definition in python
   You can use either =numpy/scipy= or =sympy=.
*** See [[https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.matrix.html][numpy docs]] . 
    :PROPERTIES:
    :BEAMER_col: 0.48
    :BEAMER_env: block
    :END:
    #+BEGIN_SRC python :exports both :results output
import numpy as np
a = np.matrix('1 2; 3 4')
print(a)
a = np.matrix([[1, 2], [3, 4]])
print(a)
a = np.array([1, 2, 3, 4]).reshape(2,2)
print(a)
    #+END_SRC
    #+LATEX: {\small
    #+RESULTS:
    : [[1 2]
    :  [3 4]]
    : [[1 2]
    :  [3 4]]
    : [[1 2]
    :  [3 4]]
    #+LATEX:}
*** See [[http://docs.sympy.org/latest/modules/matrices/matrices.html][sympy docs]]
    :PROPERTIES:
    :BEAMER_col: 0.48
    :BEAMER_env: block
    :END:

    #+BEGIN_SRC python :exports both :results output
from sympy.matrices import Matrix, eye, zeros, ones, diag
M = Matrix([[1,0,4], [0,0,0]])
print(M)
print(eye(4))
print(M[0, 2])
    #+END_SRC

    #+LATEX: {\small
    #+RESULTS:
    : Matrix([[1, 0, 4], [0, 0, 0]])
    : Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
    : 4
    #+LATEX: }

** Matrix operations in python
*** Example in python 
    :PROPERTIES:
    :BEAMER_col: 0.50
    :BEAMER_env: block
    :END:
    #+NAME: example1
    #+BEGIN_SRC python :exports both :results output
import numpy as np
a = np.matrix('1 2; 3 4')
b = np.matrix([[5, -1], [-3, 24]])
c = a+b # sum
print(c)
c = a*b # Multiplication
print(c)
c = a/b # multiply by the inverse of b
print(c)
print(c.max())
print(c.min())
d = np.array([[5, -1], [-3, 24]])
print("d:\n",d)
    #+END_SRC

*** Output     
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:
    #+RESULTS: example1
    #+begin_example
    [[ 6  1]
     [ 0 28]]
    [[-1 47]
     [ 3 93]]
    [[ 0.2        -2.        ]
     [-1.          0.16666667]]
    0.2
    -2.0
    d:
     [[ 5 -1]
     [-3 24]]
    #+end_example
   
** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
   You can watch : https://www.youtube.com/watch?v=XkY2DOUCWMU

* Solving linear systems $Ax = b$ 
** Example
   Solve the following linear system  (See [[https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html][numpy linalg]]) \\

   #+attr_latex: :width 0.6\textwidth :float t :placement [H] :center
   [[file:fig/linear-example-01.pdf]]

   #+beamer: \pause

   #+name: solveexample
   #+BEGIN_SRC python :exports both :results output 
import numpy as np

A = np.array([[150, -100, 0], [-100, 150, -50], [0, -50, 50]])
b = np.array([588.6, 686.7, 784.8])
x = np.linalg.solve(A, b) # magic
print(x)
# confirm
print(A.dot(x) - b)
    #+END_SRC
   #+beamer: \pause
   #+latex: {\vspace*{-4ex}\small
   #+RESULTS: solveexample
   : [41.202 55.917 71.613]
   : [1.25055521e-12 6.82121026e-13 2.27373675e-13]
   #+latex: }

** Exercise 1
   #+attr_latex: :width 0.9\textwidth :float t :placement [H] :center
   [[file:fig/linear-example-03.pdf]]   
   
   Solve the system. 

** Exercise 2
   Solve the following system\\
   #+attr_latex: :width 0.6\textwidth :float t :placement [H] :center
   [[file:fig/linear-example-02.pdf]]

   Can you measure the time spent?
** Exercise 3
   #+latex: \vfill\vfill
   Solve this system: 
   $$ \frac{-2.3x_1}{5} + x_2 = 1.1 $$
   $$-0.5x_1 + x_2 = 1 $$
   #+latex: \vfill   
   Plot the system of equations and check whether this solution is or
   not special.
   #+latex: \vfill

** Exercise 4: Simulating temperature
   #+latex: \vfill
   #+attr_latex: :width 0.8\textwidth :float t :placement [H] :center
   [[file:fig/linear-example-04-T.pdf]]

   #+attr_latex: :width 0.8\textwidth :float t :placement [H] :center
   [[file:fig/linear-example-04-T-B.pdf]]
   #+latex: \vfill

** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
* Computing the determinant
** Using =scipy=  
   See the [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.det.html#scipy.linalg.det][docs for determinant]]
   #+beamer: \pause
   #+NAME: detexample
   #+BEGIN_SRC python :exports both :results output 
from scipy import linalg
import numpy as np
A = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(linalg.det(A))
A = np.array([[0,2,3], [4,5,6], [7,8,9]])
print(linalg.det(A))
  #+END_SRC
  #+beamer: \pause

  #+RESULTS: detexample
  : 0.0
  : 3.0

  You can watch : https://www.youtube.com/watch?v=Ip3X9LOh2dk
** Exercise 1 
   #+attr_latex: :width 0.9\textwidth :float t :placement [H] :center
   [[file:fig/det-01.pdf]]

** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
* Computing the inverse
** Using =scipy=
   See [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.inv.html#scipy.linalg.inv][inverse with =scipy=]]
   #+BEGIN_SRC python :exports both :results output 
from scipy import linalg
import numpy as np
A = np.array([[1., 2.], [3., 4.]])
B = linalg.inv(A)
print(B)
# verify
print(A.dot(B))
   #+END_SRC

   #+RESULTS:
   : [[-2.   1. ]
   :  [ 1.5 -0.5]]
   : [[1.0000000e+00 0.0000000e+00]
   :  [8.8817842e-16 1.0000000e+00]]

   
   You can watch: https://www.youtube.com/watch?v=uQhTuRlWMxw
** Condition number
   #+latex: \vfill
   The number
   $\kappa = ||A|| ||A^{-1}||$
   is called the condition number of a matrix. Ideally it is $1$. If $\kappa$ is much
   larger than one, the matrix is ill-conditioned and the solution
   might have a lot of error.
   #+latex: \vfill
   Compute the condition number of the following matrix:
   
   \begin{equation}
   A = 
   \begin{bmatrix}
   1.001 & 0.001\\
   0.000 & 0.999
   \end{bmatrix}
   \end{equation}
   #+latex: \vfill
** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
* Matrix factorizations
** LU 
   You can specifically solve with LU factorization. See [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu_solve.html#scipy.linalg.lu_solve][docs]] .
   #+BEGIN_SRC python :exports both :results output
from scipy.linalg import lu_factor, lu_solve
import numpy as np
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
b = np.array([1, 1, 1, 1])
lu, piv = lu_factor(A)
x = lu_solve((lu, piv), b)
print(x)
print(A.dot(x) - b)
   #+END_SRC

   #+RESULTS:
   : [ 0.05154639 -0.08247423  0.08247423  0.09278351]
   : [0. 0. 0. 0.]
** Cholesky
   Or you can use the Cholesky factorization. 
   See [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve][Cholesky docs]] . The matrix must be positive definite. 
   #+BEGIN_SRC python :exports both :results output
from scipy.linalg import cho_factor, cho_solve
import numpy as np
A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])
b = np.array([1, 1, 1, 1])
c, low = cho_factor(A)
x = cho_solve((c, low), b)
print(x)
print(A.dot(x) - b)
   #+END_SRC

   #+RESULTS:
   : [-0.01749271  0.11953353  0.01166181  0.1574344 ]
   : [2.22044605e-16 2.22044605e-16 0.00000000e+00 0.00000000e+00]

** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
* Eigen value and eigen vectors
** Definition
   #+latex: \vfill
   The eigen-values and eigen-vectors of a matrix satisfy the equation 

   $$ Ax = \lambda x $$


   The eigen-vectors form a basis where the matrix can be
   diagonalized. In general, computing the eigen vectors and
   aeigenvalues is hard, and they can also be complex.
   #+latex: \vfill
   
   You can watch: https://www.youtube.com/watch?v=PFDu9oVAE-g
** Implementation in Python
   See [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig][docs for scipy]]

   #+NAME: eigen
   #+BEGIN_SRC python :exports both :results output
import numpy as np
from scipy import linalg
A = np.array([[0., -1.], [1., 0.]])
#A = np.array([[1, 0.], [0., 2.]])
#A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
#A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
sol = linalg.eig(A)
print("Eigen-values: ", sol[0])
print("Eigen-vectors:\n", sol[1])
# verify
print("Verification: ", A.dot(sol[1][:, 0]) - sol[0][0]*sol[1][:, 0])
   #+END_SRC

   #+LATEX: {\scriptsize
   #+RESULTS: eigen
   : Eigen-values:  [0.+1.j 0.-1.j]
   : Eigen-vectors:
   :  [[0.70710678+0.j         0.70710678-0.j        ]
   :  [0.        -0.70710678j 0.        +0.70710678j]]
   : Verification:  [0.+0.j 0.+0.j]
   #+LATEX: }
** Exercise 1 \cite{cheney2012numerical}
   #+latex: \vfill
   #+attr_latex: :width 1.0\textwidth :float t :placement [H] :center
   [[file:fig/eigen-exer-02.pdf]]
   #+latex: \vfill
** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
* Problems
** Problem 1
   #+latex: \vfill
   Create a random matrix, with random elements between [-1, 1], and
   make a histogram for the largest eigenvalue.
   #+latex: \vfill
** Problem 2 \cite{cheney2012numerical}
   #+attr_latex: :width 0.8\textwidth :float t :placement [H] :center
   [[file:fig/problem-01.pdf]]

** Problem 3 \cite{cheney2012numerical}
   #+latex: \vfill
   #+attr_latex: :width 1.0\textwidth :float t :placement [H] :center
   [[file:fig/problem-02.pdf]]
   #+latex: \vfill

* Acknowledgments                                                
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
** The end                                                      :B_fullframe:
   :PROPERTIES:
   :BEAMER_env: fullframe
   :BEAMER_OPT: standout,label=
   :END:
   Thank you

* Bibliography
  :PROPERTIES:
  :BEAMER_OPT: fragile,allowframebreaks,label=
  :END:      
  #+BIBLIOGRAPHY: biblio unsrt
  \bibliographystyle{unsrt}
  \bibliography{biblio} 
  \cite{*}
* A simple example : a 2D matrix                                   :noexport:
# ** Example escapecode                                              :noexport:
#    This allows tot test scape codes in minted. For now it does not
#    work, I cannot put them as comments, so either I have them in the
#    presentation or as commented code
# #+BEAMER:\newcommand\myonly[2]{\only<#1>{#2}}
# #+BEGIN_SRC c :tangle tmp.cpp :exports code
# int main(void) {
#     char *p;
#     p=(char *)malloc(5); //|\myonly{1}{$\Leftarrow$}|
#     /* do stuff */
#     p=(char *)malloc(7); //|\myonly{2}{$\Leftarrow$}|
#     free(p);
#     return 0;
# }
# #+END_SRC
# ** Matrix simple creation and printing
#    #+BEGIN_SRC cpp exports code :main no :tangle main_matrix_txt.cpp
# #include "matrix_io_txt.h"
# #include "matrix_util.h"
# #include <cmath>

# const int NX = 1024;
# const int NY = 2048;

# int main(void)
# {
#   double * A = new double [NX*NY] {0.0}; // compile with -std=c++11 or -std=c++0x
#   fill(A, NX, NY);
#   write_to_txt(A, NX, NY, "matrix.txt");
  
#   return 0;
# }
#    #+END_SRC

# ** Routine to fill the matrix
#  #+BEGIN_SRC cpp :exports none :tangle matrix_util.h :main no
#  #include <cmath>
#  void fill(double *A, int nx, int ny);
#  #+END_SRC
# #+BEGIN_SRC cpp :exports code :tangle matrix_util.cpp :main no
# #include "matrix_util.h"
# void fill(double *A, int nx, int ny)
# {
#   double x, y;
#   for(int ii = 0 ; ii < nx; ii++) {
#     for(int jj = 0 ; jj < ny; jj++) {
#       x = (nx/2 - ii); y = (ny/2 - jj);
#       A[ii*ny + jj] = 100.032*std::exp(-1.0e-5*(+x*x + y*y));
#     }
#   }
# }

# #+END_SRC
#    #+BEGIN_SRC gnuplot :file fig/table.png :exports none
#    set size ratio -1
#    set terminal png crop
#    set out "fig/table.png"
#    plot 'matrix.txt'  matrix with image
#    #+END_SRC

#    #+BEGIN_center
#    #+RESULTS:
#    #+ATTR_LATEX: :width 0.8\textwidth :center 
#    [[file:fig/table.png]]
#    #+END_center

# ** Routines to write and read back a 2D matrix (text mode)      :B_fullframe:
#    :PROPERTIES:
#    :BEAMER_env: fullframe
#    :END:
#    #+LATEX: \tiny
# #+BEGIN_SRC cpp :main no :tangle matrix_io_txt.cpp :exports code
# #include "matrix_io_txt.h"

# void write_to_txt(const double * matrix, int nx, int ny, const std::string & fname)
# {
#   auto t1 = std::chrono::high_resolution_clock::now();
#   std::ofstream fout(fname);
#   fout.precision(16); fout.setf(std::ios::scientific);
#   for(int ii = 0; ii < nx; ++ii) {
#     for(int jj = 0; jj < ny; ++jj) {
#       fout << matrix[ii*ny + jj] << "  "; 
#     }
#     fout << "\n";
#   }
#   fout.close();
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("out-txt(s): %.4lf\n", elapsed.count());
# }

# void read_from_txt(double * matrix, int nx, int ny, const std::string & fname)
# {
#   auto t1 = std::chrono::high_resolution_clock::now();
#   std::ifstream fin(fname);
#   for(int ii = 0; ii < nx; ++ii) {
#     for(int jj = 0; jj < ny; ++jj) {
#       fin >> matrix[ii*ny + jj]; 
#     }
#   }
#   fin.close();
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("in-txt(s): %.4lf\n", elapsed.count());
# }

# #+END_SRC
# #+BEGIN_SRC cpp :main no :tangle matrix_io_txt.h :exports none
# #include <string>
# #include <fstream>
# #include <iostream>
# #include <chrono>
# void write_to_txt(const double * matrix, int nx, int ny, const std::string & fname);
# void read_from_txt(double * matrix, int nx, int ny, const std::string & fname);
# #+END_SRC

# ** How much type to print? How large is a typical file?                                      
# *** Compilation                                             :B_ignoreheading:
#     :PROPERTIES:
#     :BEAMER_env: ignoreheading
#     :END:
#    We compile and run it like
#    #+BEGIN_SRC sh :exports both
#    g++ -std=c++11 main_matrix_txt.cpp matrix_io_txt.cpp matrix_util.cpp
#    ./a.out
#    #+END_SRC

#    #+RESULTS:
#    : out-txt(s): 2.438437
# *** File size                                               :B_ignoreheading:
#     :PROPERTIES:
#     :BEAMER_env: ignoreheading
#     :END:
#     :PROPERTIES:
#     :BEAMER_env: block
#     # :BEAMER_act: <2->
#     :END:
#    And the size of the written file is 
#    #+name: size
#    #+BEGIN_SRC sh :exports both
#    ls -sh matrix.txt
#    #+END_SRC

#    #+RESULTS: size
#    : 49M matrix.txt

* Saving simulation state to future use                            :noexport:
# ** Why saving intermediate states is important?                     :B_frame:
#    :PROPERTIES:
#    :BEAMER_env: frame
#    :END:
# #+LATEX: \vfill
#    - Maybe the simulation takes several days/weeks/months.
#    - Maybe the initialization is costly. 
#    - Sometimes accidents happen: power grid failure, people just turn
#      off computers, etc. 
#    - Maybe you want to perform intermediate post-processing. 
#    - etc
# *** Therefore ...                                              :B_alertblock:
#     :PROPERTIES:
#     :BEAMER_env: alertblock
#     :END:
#     - It is advisable to be able to restart the simulation.
#     - We need to read back the data at the point previous to failure!
# #+LATEX: \vfill
    
# ** Reading data back in text mode
#    :PROPERTIES:
#    :BEAMER_envargs: [t]
#    :END:
#    #+LATEX: \setbeamercovered{transparent=20}
# *** Writing and reading using text mode                       :B_block:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.5
#     :BEAMER_env: block
#     :END:
#     #+BEGIN_SRC cpp :tangle main_txt_write_read.cpp :exports code :results output
# // compile with -std=c++11 or -std=c++0x
# #include "matrix_io_txt.h"
# #include "matrix_util.h"
# #include <cmath>
# #include <iostream>

# const int NX = 1024;
# const int NY = 2048;

# int main(void)
# {
#   double * A = new double [NX*NY] {0.0}; 
#   fill(A, NX, NY);

#   write_to_txt(A, NX, NY, "matrix.txt");
#   read_from_txt(A, NX, NY, "matrix.txt");

#   return 0;
# }
#    #+END_SRC

#    #+RESULTS:

#     #+name:txtexampleB
# #+BEGIN_SRC sh :exports both
# g++ -std=c++11 main_txt_write_read.cpp matrix_io_txt.cpp matrix_util.cpp
# ./a.out    
# #+END_SRC
# *** Results                                                   :B_block:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.5
#     :BEAMER_env: block
#     :BEAMER_act: <2->
#     :END:
#     #+LATEX: \small
#     #+results: txtexampleB
#     | out-txt(s): | 2.60253 |
#     | in-txt(s):  |   3.542 |

# **** Remarks                                                        :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :BEAMER_act: <2->
#     :END:
#     - This is taking a lof of time. How to solve it?    
#     - *The solution might be to print to a binary file.*

# ** Printing to binary
# *** Model functions                                             :B_fullframe:
#     :PROPERTIES:
#     :BEAMER_env: fullframe
#     :END:
# #+BEGIN_SRC cpp :main no :tangle matrix_io_bin.h :exports none
# #include <fstream>
# #include <iostream>
# #include <chrono>
# void write_to_bin(const double * matrix, int nx, int ny, const std::string & fname);    
# void read_from_bin(double * matrix, int nx, int ny, const std::string & fname);    
# #+END_SRC
#    #+BEGIN_SRC cpp :main no :tangle matrix_io_bin.cpp :exports code
# #include "matrix_io_bin.h"

# void write_to_bin(const double * matrix, int nx, int ny, const std::string & fname)
# {
#   auto t1 = std::chrono::high_resolution_clock::now();
#   std::ofstream fout(fname, std::ios::binary);
#   for(int ii = 0; ii < nx; ++ii) {
#     for(int jj = 0; jj < ny; ++jj) {
#       fout.write((char *)&matrix[ii*ny + jj], sizeof(double));
#     }
#   }
#   fout.close();
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("out-bin(s): %.4lf\n", elapsed.count());
# }

# void read_from_bin(double * matrix, int nx, int ny, const std::string & fname)
# {
#   auto t1 = std::chrono::high_resolution_clock::now();
#   std::ifstream fin(fname, std::ios::binary);
#   for(int ii = 0; ii < nx; ++ii) {
#     for(int jj = 0; jj < ny; ++jj) {
#       fin.read((char *)&matrix[ii*ny + jj], sizeof(double)); 
#     }
#   }
#   fin.close();
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("in-bin(s): %.4lf\n", elapsed.count());
# }
#    #+END_SRC
# ** Writing/reading in binary mode                             :B_block:BMCOL:
#    #+LATEX: \setbeamercovered{transparent=15}
# *** Main function
#     :PROPERTIES:
#     :BEAMER_col: 0.5
#     :BEAMER_env: block
#     :END:   
# #+BEGIN_SRC cpp :tangle main_bin_io.cpp :exports code :results output
# // compile with -std=c++11 or -std=c++0x
# #include "matrix_io_txt.h"
# #include "matrix_io_bin.h"
# #include "matrix_util.h"
# #include <cmath>
# #include <iostream>
# const int NX = 1024;
# const int NY = 2048;
# int main(void)
# {
#   double * A = new double [NX*NY] {0.0}; 

#   fill(A, NX, NY);

#   write_to_txt(A, NX, NY, "matrix.txt");
#   write_to_bin(A, NX, NY, "matrix.dat");
#   read_from_txt(A, NX, NY, "matrix.txt");
#   read_from_bin(A, NX, NY, "matrix.dat");
#   return 0;
# }
#    #+END_SRC
# #+NAME: binexample
# #+BEGIN_SRC sh :exports results
# g++ -std=c++11 main_bin_io.cpp matrix_io_txt.cpp matrix_io_bin.cpp matrix_util.cpp -lnetcdf
# ./a.out    
# #+END_SRC

# #+NAME: binsizeexample
# #+BEGIN_SRC sh :exports results
# ls -sh matrix.{txt,dat}
# #+END_SRC

# *** Results                                                   :B_block:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.5
#     :BEAMER_env: block
#     :BEAMER_act: <2->
#     :END:
#     #+:LATEX: \small
#     #+results: binexample
#     | out-txt(s): |  2.52711 |
#     | out-bin(s): |  0.10363 |
#     | in-txt(s):  |   3.4034 |
#     | in-bin(s):  | 0.084382 |
#     #+:LATEX: \small
#     #+results: binsizeexample
#     | 16M | matrix.dat |
#     | 49M | matrix.txt |

#     - *This is very good. Printing is faster and produces smaller
#       files, but ...* 

* Portability                                                      :noexport:
# ** Sharing results
#    1. Now I (proudly) send the final result to my supervisor. 
#    2. But he works on windows and strangely he cannot read the data!
#    3. What happened? Now I am in trouble. *Binary formats are not
#       portable*!

#    This could happen if:
#    - You are using platforms with different endianess
#    - Embedded/exotic platforms
#    - You are not using standard IEEE754 datatypes

#    How to solve this? Find a binary portable data format. 
#    So you need to go to serialization $\to$ Lot of work! 
   
# ** Finding the right data format
#    #+LATEX: \vfill
#    *[[http://bfy.tw/GfdJ][Let me google that for you]]*

#    [[https://en.wikipedia.org/wiki/List_of_file_formats#Scientific_data_(data_exchange)][Scientific_data]]

#    #+LATEX: \vfill
# *** Portable data formats                                           :B_block:
#    :PROPERTIES:
#    :BEAMER_act: <2->
#    :BEAMER_env: block
#    :END:
#    #+attr_latex: :width 0.3\textwidth
#    [[file:fig/netcdf.png]]
#    #+LATEX: \hfill
#    #+attr_latex: :width 0.3\textwidth
#    [[file:fig/HDF_logo.svg.png]] 
#    #+LATEX: \hfill
#    #+attr_latex: :width 0.3\textwidth
#    [[file:fig/XdmfLogo1.png]]

#    - xdmf (wrapper to hdf5 with lightweight metadata)

# ** What is netcdf? (~module load netcdf~)
# *** From [[https://www.unidata.ucar.edu/software/netcdf/][unidata site]]              :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
#     NetCDF is a set of software libraries and self-describing,
#     machine-independent data formats that support the creation, access,
#     and sharing of array-oriented scientific data (Latest version
#     4.6.0). 

#    - Self-describing :: It has metadata about the data it contains. 
#    - Portable :: /Can be accessed by different platforms!/
#    - Scalable :: Small subsets can be accessed efficiently. 
#    - Appendable :: Data may be appended without redefining the
#                    structure.  
#    - Sharable :: Multiple access to the same file. 
#    - Bindings :: You can use it from ~c~, ~c++~, ~python~, ~fortran~
#    - HDF5 :: Already uses hdf5 underlying, but much more easy to
#              handle. 
#    - Criticism :: Not a database system, no transactions, parallel io
#                   through another package (no longer true). 

* Implementing netcdf for our example                              :noexport:
#   # https://stackoverflow.com/questions/33223778/writing-compressed-files-using-nc-create
# ** Printing                                                     :B_fullframe:
#    :PROPERTIES:
#    :BEAMER_env: fullframe
#    :END:
#    For our simple example, this is a simple routine to write a
#    ~netcdf~ file. You can create compound types or just write arrays. 
#    #+BEGIN_SRC cpp :tangle matrix_io_netcdf.h :exports none :main no
#    #ifndef netcdf_header
#    #define netcdf_header
#    #include <string>
#   #include <chrono>
#   #include <iostream>
#    #include <netcdf.h>
#    void write_to_netcdf(const double *A, int NX, int NY, const std::string & fname, int deflate_level);
#    void read_from_netcdf(double *A, const std::string & fname);
#    #endif
#    #+END_SRC

#    #+BEGIN_SRC cpp :tangle matrix_out_netcdf.cpp :exports code :main no
# // based on https://www.unidata.ucar.edu/software/netcdf/examples/programs/simple_xy_wr.c
# #include "matrix_io_netcdf.h"
# void write_to_netcdf(const double *A, int NX, int NY, const std::string & fname, 
#                      int deflate_level)
# {
#   const int NDIMS = 2; 
#   int ncid, dimids[NDIMS], varid;
#   auto t1 = std::chrono::high_resolution_clock::now();
#   nc_create(fname.c_str(), NC_CLOBBER | NC_NETCDF4, &ncid);
#   /* Define the dimensions. NetCDF will hand back an ID for each. */
#   nc_def_dim(ncid, "x", NX, &dimids[0]);
#   nc_def_dim(ncid, "y", NY, &dimids[1]);
#   nc_def_var(ncid, "data", NC_DOUBLE, NDIMS, dimids, &varid);
#   /* set COMPRESSION!!!! This works better for non-contiguous data*/
#   int shuffle = 0, deflate = 1; 
#   nc_def_var_deflate(ncid, varid, shuffle, deflate, deflate_level);
#   nc_enddef(ncid); // done defining data

#   nc_put_var_double(ncid, varid, &A[0]); // write all data
#   nc_close(ncid);
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("out-netcdf(s): %.4lf\n", elapsed.count());
# }
#    #+END_SRC
# ** Reading                                                      :B_fullframe:
#    :PROPERTIES:
#    :BEAMER_env: fullframe
#    :END:
#     Now read it by using the same interface,
#     #+BEGIN_SRC cpp :main no :exports code :tangle matrix_in_netcdf.cpp
# #include "matrix_io_netcdf.h"

# void read_from_netcdf(double *A, const std::string & fname)
# {
#   int ncid, varid;
#   auto t1 = std::chrono::high_resolution_clock::now();
#   nc_open(fname.c_str(), NC_NOWRITE, &ncid);
#   nc_inq_varid(ncid, "data", &varid); // variable name
#   nc_get_var_double(ncid, varid, &A[0]); // A must have the right size
#   nc_close(ncid);
#   auto t2 = std::chrono::high_resolution_clock::now();
#   std::chrono::duration<double> elapsed = t2 - t1;
#   std::printf("in-netcdf(s): %.4lf\n", elapsed.count());
# }
#     #+END_SRC
# ** Using them
# #+BEGIN_SRC cpp :tangle main_netcdf.cpp :exports code :main no
# #include <iostream>
# #include "matrix_util.h"
# #include "matrix_io_txt.h"
# #include "matrix_io_bin.h"
# #include "matrix_io_netcdf.h"

# const int NX = 1024;
# const int NY = 2048;

# int main(void)
# {
#   double * data = new double [NX*NY] {0.0}; // compile with -std=c++11 or -std=c++0x

#   fill(data, NX, NY);

#   write_to_txt(data, NX, NY, "matrix.txt");
#   write_to_bin(data, NX, NY, "matrix.dat");
#   write_to_netcdf(data, NX, NY, "matrix-deflate1.nc", 1);
#   write_to_netcdf(data, NX, NY, "matrix-deflate9.nc", 9);

#   read_from_txt(data, NX, NY, "matrix.txt");
#   read_from_bin(data, NX, NY, "matrix.dat");
#   read_from_netcdf(data, "matrix-deflate1.nc");
#   read_from_netcdf(data, "matrix-deflate9.nc");
    
#   return 0;
# }
# #+END_SRC      

# ** Results
# *** Compiling and running                                           :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
# #+name:fulltest-matrix
# #+BEGIN_SRC sh :exports both
# g++  -std=c++11 main_netcdf.cpp matrix_out_netcdf.cpp matrix_in_netcdf.cpp \
#  matrix_io_txt.cpp matrix_io_bin.cpp matrix_util.cpp -lnetcdf && ./a.out
# ls -sh matrix-deflate*.nc matrix.{txt,dat} | column -c 1
# #+END_SRC

# #+LATEX: {\small
# #+RESULTS: fulltest-matrix
# | out-txt(s):    |             2.0044 |
# | out-bin(s):    |           0.084141 |
# | out-netcdf(s): |            0.65417 |
# | out-netcdf(s): |           0.715386 |
# | in-txt(s):     |            2.93902 |
# | in-bin(s):     |           0.063446 |
# | in-netcdf(s):  |           0.091126 |
# | in-netcdf(s):  |           0.090724 |
# | 14M            | matrix-deflate1.nc |
# | 14M            | matrix-deflate9.nc |
# | 16M            |         matrix.dat |
# | 49M            |         matrix.txt |
# #+LATEX: }

# ** Netcdf tools to process data
# #   You can use some ~netcdf~ tools to explore your ~.nc~ files. 
# *** Command line tools
#     - ~nccopy~ :: Copy a netCDF file, optionally changing format,
#                   compression, or chunking in the output. 
#     - ~ncdump~ :: Convert netCDF file to text form (CDL). 
#     - ~ncgen~ :: From a CDL file generate a netCDF-3 file, a netCDF-4
#                  file or a C program. 
# #+name: cdl
# #+BEGIN_SRC sh :exports both
# ncdump -h matrix-deflate1.nc
# #+END_SRC    

# #+LATEX: {\scriptsize
# #+RESULTS: cdl
# | netcdf      | matrix-deflate1 | {       |      |   |
# | dimensions: |                 |         |      |   |
# |             | x               | =       | 1024 | ; |
# |             | y               | =       | 2048 | ; |
# | variables:  |                 |         |      |   |
# |             | double          | data(x, |   y) | ; |
# | }           |                 |         |      |   |
# #+LATEX: }

# ** Example of a CDL file
# #+BEGIN_EXAMPLE
# netcdf co2 {
# dimensions:
# 	T = 456 ;
# variables:
# 	float T(T) ;
# 		T:units = "months since 1960-01-01" ;
# 	float co2(T) ;
# 		co2:long_name = "CO2 concentration by volume" ;
# 		co2:units = "1.0e-6" ;
# 		co2:_FillValue = -99.99f ;

# // global attributes:
# 		:references = "Keeling_etal1996, Keeling_etal1995" 
# #+END_EXAMPLE

* Post-processing: Paraview and netcdf                             :noexport:
#   # https://stackoverflow.com/questions/25037348/can-paraview-read-my-netcdf4-hdf5-file?rq=1
# ** What is Paraview? [[https://www.paraview.org]]
# *** ~module load paraview~                                            :BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.4
#     :END:
#     [[file:fig/paraview_logo.png]]
#     #+ATTR_LaTeX: :width 1.0\linewidth :float t :placement [H]
#     [[file:fig/1_full_lox.png]]
#     #+ATTR_LaTeX: :width 1.0\linewidth :float t :placement [H]
#     [[file:fig/Screenshot_OpenFOAM_smallPoolFire2D_ParaView_3.12.0.png]]
# *** Paraview                                                          :BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.60
#     :END:
#     #+LATEX: \vspace*{-4ex}
#     - ParaView is an open-source, multi-platform data analysis and
#       visualization application.
#     - Support *distributed* computation models to process large data
#       sets, including both cpu and gpu. 
#     - Many file readers, including netcdf!
#     - Allows post-processing and data analysis. 
#     - Python scripting to create powerful visualizations. 
#     - Deployed on Windows, Mac OS X, Linux, SGI, IBM Blue Gene, Cray
#       and various Unix workstations, clusters and supercomputers 

# ** Example with our data                                        :B_fullframe:
#    :PROPERTIES:
#    :BEAMER_env: fullframe
#    :END:
#    #+LATEX: \vfill
#    #+BEGIN_CENTER
#    #+attr_latex: :width 1.0\textwidth :float t :placement [H] :center
#    [[file:fig/paraview-screenshot.png]]
#    #+END_CENTER
#    #+LATEX: \vfill

* Beyond : Parallel netcdf                                         :noexport:
# ** Direct support in netcdf-4
#    See https://www.unidata.ucar.edu/software/netcdf/docs/netcdf__par_8h.html#details
#    - ~nc_var_par_access~ : Sets parallel access to collective or
#      independent. 
#    - ~nc_create_par~ : Creates a new netCDF file for parallel I/O (~NC_NETCDF4|NC_MPIIO~)
#      access.
#      #+BEGIN_SRC cpp :exports code
#      int nc_create_par (const char * path, int cmode, MPI_Comm comm, 
#                         MPI_Info info, int * ncidp);
#      #+END_SRC
#    - ~nc_open_par()~ : Opens a file in parallel mode
#    - There is another available project: https://trac.mcs.anl.gov/projects/parallel-netcdf
# ** Example in the cluster
#    Example from:
#    https://www.unidata.ucar.edu/software/netcdf/netcdf-4/newdocs/netcdf-c/parallel-access.html
#    #+BEGIN_SRC c :exports none :tangle parallel_netcdf.c
# #include "netcdf.h"
# #include "netcdf_par.h"
# #include <mpi.h>
# #include <assert.h>
# #include "hdf5.h"
# #include <string.h>
# #include <stdlib.h>

# #define BAIL(e) do {                                                    \
#     printf("Bailing out in file %s, line %d, error:%s.\n", __FILE__, __LINE__, nc_strerror(e)); \
#     return e;                                                           \
#   } while (0)

# #define FILE "test_par.nc"
# #define NDIMS 2
# // #define DIMSIZE 
# #define DIMSIZE 1450
# #define QTR_DATA (DIMSIZE*DIMSIZE/4)
# #define NUM_PROC 4

# int
# main(int argc, char **argv)
# {
#   /* MPI stuff. */
#   int mpi_namelen;
#   char mpi_name[MPI_MAX_PROCESSOR_NAME];
#   int mpi_size, mpi_rank;
#   MPI_Comm comm = MPI_COMM_WORLD;
#   MPI_Info info = MPI_INFO_NULL;

#   /* Netcdf-4 stuff. */
#   int ncid, v1id, dimids[NDIMS];
#   size_t start[NDIMS], count[NDIMS];

#   int data[DIMSIZE*DIMSIZE], j, i, res;

#   /* Initialize MPI. */
#   MPI_Init(&argc,&argv);
#   MPI_Comm_size(MPI_COMM_WORLD, &mpi_size);
#   MPI_Comm_rank(MPI_COMM_WORLD, &mpi_rank);
#   MPI_Get_processor_name(mpi_name, &mpi_namelen);
#   printf("mpi_name: %s size: %d rank: %d\n", mpi_name,
#          mpi_size, mpi_rank);

#   double t1 = MPI_Wtime();
#   /* Create a parallel netcdf-4 file. */
#   if ((res = nc_create_par(FILE, NC_NETCDF4|NC_MPIIO, comm,
#                            info, &ncid)))
#     BAIL(res);

#   /* Create two dimensions. */
#   if ((res = nc_def_dim(ncid, "d1", DIMSIZE, dimids)))
#     BAIL(res);
#   if ((res = nc_def_dim(ncid, "d2", DIMSIZE, &dimids[1])))
#     BAIL(res);

#   /* Create one var. */
#   if ((res = nc_def_var(ncid, "v1", NC_INT, NDIMS, dimids, &v1id)))
#     BAIL(res);

#   if ((res = nc_enddef(ncid)))
#     BAIL(res);

#   /* Set up slab for this process. */
#   start[0] = mpi_rank * DIMSIZE/mpi_size;
#   start[1] = 0;
#   count[0] = DIMSIZE/mpi_size;
#   count[1] = DIMSIZE;
#   printf("mpi_rank=%d start[0]=%d start[1]=%d count[0]=%d count[1]=%d\n",
#          mpi_rank, start[0], start[1], count[0], count[1]);

  
#   /* Create phony data. We're going to write a 24x24 array of ints,
#      in 4 sets of 144. */
#   printf("mpi_rank*QTR_DATA=%d (mpi_rank+1)*QTR_DATA-1=%d\n",
#          mpi_rank*QTR_DATA, (mpi_rank+1)*QTR_DATA);
#   for (i=mpi_rank*QTR_DATA; i<(mpi_rank+1)*QTR_DATA; i++)
#     data[i] = mpi_rank;

#   /*if ((res = nc_var_par_access(ncid, v1id, NC_COLLECTIVE)))
#     BAIL(res);*/
#   if ((res = nc_var_par_access(ncid, v1id, NC_INDEPENDENT)))
#     BAIL(res);

#   /* Write slabs of phony data. */
#   if ((res = nc_put_vara_int(ncid, v1id, start, count,
#                              &data[mpi_rank*QTR_DATA])))
#     BAIL(res);

#   /* Close the netcdf file. */
#   if ((res = nc_close(ncid)))
#     BAIL(res);
#   double t2 = MPI_Wtime();
#   printf("Time for rank %d was %.5lf\n", mpi_rank, t2-t1);
  
#   /* Shut down MPI. */
#   MPI_Finalize();

#   return 0;
# }
#    #+END_SRC
#    #+BEGIN_SRC c :exports code
#    MPI_Init(&argc,&argv);
#    ...
#    nc_create_par(FILE, NC_NETCDF4|NC_MPIIO, comm,
#                                   info, &ncid);
#    ... 
#    nc_var_par_access(ncid, v1id, NC_COLLECTIVE);
#    ...
#    nc_put_vara_int(ncid, v1id, start, count,
#                    &data[mpi_rank*QTR_DATA]);
#    #+END_SRC
  
#    To test it on Abacus-I: 
#    #+BEGIN_SRC sh :exports code
#    module load netCDF/c/4.4.1-rc2
#    module load netCDF/parallel/1.7.0
#    mpicc parallel_netcdf.c  -lpnetcdf -lnetcdf -lhdf5 -lhdf5_hl
#    mpiexec.hydra -np 4 -ppn 4 ./a.out
#    #+END_SRC
# ** Results
# #+BEGIN_SRC sh :exports code
# $ mpiexec.hydra -np 4 -ppn 4 ./a.out # run it in the cluster, not the login node
# mpi_name: service0 size: 4 rank: 2
# mpi_name: service0 size: 4 rank: 0
# mpi_name: service0 size: 4 rank: 3
# mpi_name: service0 size: 4 rank: 1
# mpi_rank=3 start[0]=18 start[1]=0 count[0]=6 count[1]=24
# mpi_rank*QTR_DATA=432 (mpi_rank+1)*QTR_DATA-1=576
# mpi_rank=2 start[0]=12 start[1]=0 count[0]=6 count[1]=24
# mpi_rank*QTR_DATA=288 (mpi_rank+1)*QTR_DATA-1=432
# mpi_rank=1 start[0]=6 start[1]=0 count[0]=6 count[1]=24
# mpi_rank*QTR_DATA=144 (mpi_rank+1)*QTR_DATA-1=288
# mpi_rank=0 start[0]=0 start[1]=0 count[0]=6 count[1]=24
# mpi_rank*QTR_DATA=0 (mpi_rank+1)*QTR_DATA-1=144
# Time for rank 0 was 0.6946
# Time for rank 1 was 0.6946
# Time for rank 2 was 0.6946
# Time for rank 3 was 0.6948
# #+END_SRC
# #+BEGIN_SRC sh :exports code
# -rw-r--r-- 1 user6  8.1M Feb 20 11:39 test_par.nc
# #+END_SRC
# #+BEGIN_SRC sh :exports none
#  $ ncdump test_par.nc
# netcdf test_par {
# dimensions:
# 	d1 = 24 ;
# 	d2 = 24 ;
# variables:
# 	int v1(d1, d2) ;
# data:

#  v1 =
#   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#   ...
#   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
# ...
# }
# #+END_SRC

# ** Conclusions                                                      :B_frame:
#    :PROPERTIES:
#    :BEAMER_env: frame
#    :END:
#    #+LATEX: \vfill
#    The ~netcdf4~ file format offers you a tool to write files that are
#    - binary portable
#    - compressed
#    - self-describing
#    - easy to use from c, python, fortran, R, ...
#    - can be directly visualized in paraview (and xmgrace)
#    - can write in parallel (work in progress)
#    #+LATEX: \vfill

* Beyond : XDMF                                                    :noexport:
#   XDMF allows to include extra metadata. Simple example:
# #+BEGIN_SRC txt :exports code
# <?xml version="1.0" ?>
# <!DOCTYPE Xdmf SYSTEM "Xdmf.dtd" []>
# <Xdmf xmlns:xi="http://www.w3.org/2001/XInclude" Version="2.0">
#    <Domain>
#       <Grid Name="gridxyz">
#         <Topology TopologyType="3DSMesh" NumberOfElements="064 0129 0513">
#         </Topology>
# <!-- Read Coordinates -->
#         <Geometry GeometryType="X_Y_Z">
#            <DataItem Name="X" Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                        grid.nc:/gridx
#            </DataItem>
#            <DataItem Name="Y" Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                        grid.nc:/gridy
#            </DataItem>
#            <DataItem Name="Z" Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                        grid.nc:/gridz
#            </DataItem>
#         </Geometry>
# <!-- Read Scalar -->
#         <Attribute Name="ux1" AttributeType="Scalar" Center="node">
#            <DataItem Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                 fields021.nc:/ux1
#            </DataItem>
#         </Attribute>
#         <Attribute Name="uy1" AttributeType="Scalar" Center="node">
#            <DataItem Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                 fields021.nc/uy1
#            </DataItem>
#         </Attribute>
#         <Attribute Name="uz1" AttributeType="Scalar" Center="node">
#            <DataItem Format="HDF" NumberType="Float" Precision="8" Dimensions="0064 0129 0513">
#                 fields021.nc:/uz1
#            </DataItem>
#         </Attribute>
#      </Grid>
#    </Domain>
# </Xdmf>
# #+END_SRC

* Commented model                                                  :noexport:
# * Introduction
# ** An alternative title page for a section
#    # usually I leave the heading empty (just spaces)
#    # this is the only good way of making section title slides
#    # I have found up to now.

#    #+BEGIN_EXPORT beamer
#    \vspace{0.3\textheight}
#    \begin{center}
#      \begin{minipage}[h]{.75\textwidth}
#        \centering
#        {\Huge Introduction}
#      \end{minipage}
#    \end{center}
#    #+END_EXPORT
# ** Instructions
#    Look at the *Org source* file to learn about available options. I also
#    added many comments explaining the usage, there.
#    - generating presentation notes.
#    - inserting a table of contents with the current section highlighted at
#      the beginning of each section.
#    - configuring transparency of yet uncovered overlay elements.
     
# ** Org mode version information

#    #+LATEX: \small
#   #+BEGIN_SRC emacs-lisp :results output :exports results :eval yes
#     (princ (concat (format "Emacs version:\n%s\n" (emacs-version))
#                    (format "\norg version: %s\n" (org-version))))
    
#   #+END_SRC

#   #+RESULTS:
#   : Emacs version:
#   : GNU Emacs 24.5.1 (x86_64-unknown-linux-gnu, GTK+ Version 3.10.8)
#   :  of 2015-05-04 on dflt1w
#   : 
#   : org version: 8.2.10


# ** Sources and Links
# - I started this example based on [[http://orgmode.org/worg/exporters/beamer/tutorial.html][the Worg hosted example by Eric S. Fraga]]
# - Basic LaTeX Beamer links
#   - [[http://www2.informatik.hu-berlin.de/~mischulz/beamer.html][An introduction to Beamer (German)]]
#   - great [[https://github.com/fniessen/refcard-org-beamer][beamer reference card]] by Fabrice Niessen on GitHub.
#   - nice link for choosing a theme: [[http://www.hartwork.org/beamer-theme-matrix/][beamer theme matrix]]
#   - [[http://www.mathematik.uni-leipzig.de/~hellmund/LaTeX/beamer2.pdf][nice example of beamer features (pure Latex)]]
#   - [[http://www.math.utah.edu/~smith/AmberSmith_GSAC_Beamer.pdf][Presentations using Latex - the Beamer Class]] by Amber Smith. Excellent
#     introduction showing many beamer features.

# *** Note							     :B_note:
#     :PROPERTIES:
#     :BEAMER_env: note
#     :END:
#     - an example of a note
# ** A simple slide
# This slide consists of some text with a number of bullet points:
# - the first, very *important*, point!
# - the previous point shows the use of the special markup which
#   translates to the Beamer specific /alert/ command for highlighting
#   text.
# The above list could be numbered or any other type of list and may
# include sub-lists.

# ** A more complex slide
#    This slide illustrates the use of Beamer blocks.  The following text,
# with its own headline, is displayed in a block:
# *** Org mode increases productivity				  :B_theorem:
#     :PROPERTIES:
#     :BEAMER_env: theorem
#     :END:
#     - org mode means not having to remember \LaTeX commands.
#     - it is based on ascii text which is inherently portable.
#     - Emacs!

#     \hfill \(\qed\)

# ** Tables
#    The size of the table font can be chosen by giving a =#+LATEX: \small=
#    command (or =\tiny= or =\footnotesize=)

#    #+LATEX: \footnotesize
#     #+NAME: tblWNs2014
#     | WNs | Processors         | Cores/node | HS06/node | total cores | total HS06 |
#     |-----+--------------------+------------+-----------+-------------+------------|
#     |  20 | 2*Xeon X5560       |          8 |       118 |         160 |       2360 |
#     |  11 | 2*E5-2670 2.60GHz  |         16 |       263 |         176 |       2893 |
#     |   4 | 2*AMD 6272 2.40GHz |         32 |       241 |         128 |        964 |
#     |-----+--------------------+------------+-----------+-------------+------------|
#     |  35 |                    |            |           |         464 |       6217 |
# #+TBLFM: @I$6..@II$6=$1*$4::@I$5..@II$5=$1*$3::@>$1=vsum(@I..@II)::@>$5..@>$6=vsum(@I..@II)

# ** This is a notes page						     :B_note:
#    :PROPERTIES:
#    :BEAMER_env: note
#    :END:

#    This is a notes page with some information.
   
# * A collection of example pages
# ** block environments
   
# *** a block							    :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
#     #+BEGIN_EXAMPLE
#     \begin{block}{A block}
#     ...
#     \end{block}
#     #+END_EXAMPLE

# *** an alert block					       :B_alertblock:
#     :PROPERTIES:
#     :BEAMER_env: alertblock
#     :END:
#     #+BEGIN_EXAMPLE
#     \begin{alertblock}{An alert block}
#     ...
#     \end{alertblock}
#     #+END_EXAMPLE

# *** an example block					     :B_exampleblock:
#     :PROPERTIES:
#     :BEAMER_env: exampleblock
#     :END:
#     #+BEGIN_EXAMPLE
#     \begin{exampleblock}{An alert block}
#     ...
#     \end{exampleblock}
#     #+END_EXAMPLE

# ** some more blocks
# *** a color box						   :B_beamercolorbox:
#     :PROPERTIES:
#     :BEAMER_env: beamercolorbox
#     :END:
#     The beamercolorbox does not seem to work
#     #+BEGIN_EXAMPLE
#     \begin{beamercolorbox}[shadow=true, rounded=true]{eecks}
#     ...
#     \end{beamercolorbox}
#     #+END_EXAMPLE
     
# ** fullframe							:B_fullframe:
#    :PROPERTIES:
#    :BEAMER_env: fullframe
#    :END:

#    A =fullframe= is a =frame= with an ignored slide
#    title. =frametitle= is set to the empty string

# ** ignoreheading					    :B_ignoreheading:
#    :PROPERTIES:
#    :BEAMER_env: ignoreheading
#    :END:

#    - A headline with an =ignoreheading= environment will only have its contents
#      displayed in the output. The heading text itself is ignored, and no
#      heading bar is shown.
#      + Contents are not inserted in any =frame= environment. It makes no sense
#        to use this as major element for a slide.

#    - ignoreheading is useful as a structural element in order to again
#      place normal text after a previous element (like a block or a
#      column environment).

# ** =structureenv= environment
# *** structureenv 					     :B_structureenv:
#     :PROPERTIES:
#     :BEAMER_env: structureenv
#     :END:
#     - For highlighting text.
#     - To help the audience see the structure of your presentation.
#     - On this slide you should see that the text of the upper items is
#       differently typeset from the bottom item in the /structureenv/.

# *** end of structureenv					    :B_ignoreheading:
#     :PROPERTIES:
#     :BEAMER_env: ignoreheading
#     :END:
#     - you need to use =ignoreheading= (like here) in order to then
#       insert some more normal text after the structureenv.

# ** =definition= environment

   
# *** definition						       :B_definition:
#     :PROPERTIES:
#     :BEAMER_env: definition
#     :END:
#     Contents of the definition

# ** =proof= environment and revealing line by line
# *** proof							    :B_proof:
#     :PROPERTIES:
#     :BEAMER_env: proof
#     :END:
#     - <1-| alert@1> Suppose /p/ were the largest prime number.
#     - <2-> Let /q/ be the product of the first /p/ numbers.
#     - <3-> Then /q + 1/ is not divisible by any of them.
#     - <4-> But /q + 1/ is greater than /1/, thus divisible by some prime number
#       not in the first /p/ numbers.\qedhere

# ** numbered list over two pages (1)
#    1. one
#    2. two
#    3. three
#    4. four
# ** numbered list over two pages (2)
#    Use the =[@N]= syntax to start a numbered list at a certain value.

# *** block A							    :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
#     5. [@5] five
#     6. six
#     7. seven
# *** block B							    :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
#     8. [@8] eight
#     9. nine
#     10. ten

# ** long source code over two pages
#    :PROPERTIES:
#    :BEAMER_opt: allowframebreaks,label=
#    :END:

#    Use the =allowframebreaks= Beamer option.
#    #+LATEX: \small
#    #+BEGIN_SRC emacs-lisp
#      (use-package python
#        :config (progn
#                  ;; load my own python helper functions
#                  (load-file (concat dfeich/site-lisp "/my-pydoc-helper.el"))

#                  (defun dfeich/python-keydefs ()
#                    (define-key python-mode-map (kbd "<M-right>")
#                      'python-indent-shift-right)
#                    (define-key python-mode-map (kbd "<M-left>")
#                      'python-indent-shift-left))
#                  (add-hook 'python-mode-hook #'dfeich/python-keydefs)

#                  ;; show line numbers on the left for python
#                  (add-hook 'python-mode-hook 'linum-mode)

#                  (when (featurep 'flycheck)
#                    (add-hook 'python-mode-hook 'flycheck-mode))
            
#                  (use-package jedi-core
#                    :ensure t
#                    :config (progn
#                              (autoload 'jedi:setup "jedi-core" nil t)
#                              (add-hook 'python-mode-hook 'jedi:setup)
#                              (setq jedi:complete-on-dot t)
#                              (setq jedi:server-args '("--log" "/tmp/jedi.log"
#                                                       "--log-level" "INFO"))
#                              (when (featurep 'company)
#                                (defun dfeich/python-mode-hook ()
#                                  (add-to-list 'company-backends 'company-jedi)
#                                  )
#                                (add-hook 'python-mode-hook 'dfeich/python-mode-hook))))))
#    #+END_SRC


# * Animations by overlays
# ** Highlighting text

#    The double =@@= can be used to enclose active code. Here we use it to specify
#    beamer code that will highlight text by specifying an overlay.
   
#    A *@@beamer:<2->@@useful* feature

# ** Lists
#    For the first list we use an =#+ATTR_BEAMER: :overlay +-= specification.

#    It acts like =\begin{itemize}[<+->]=. So, it will cause the
#    list items to appear one after the other.

#    #+ATTR_BEAMER: :overlay +-
#    - item 1
#    - item 2
#    - item 3

#    For the second list we classify each line by angular brackets to
#    explicitely define the order of revealing each item.
#    - <1-> item 1
#    - <3-> item 2
#    - <2-> item 3

# ** Basic revealing of blocks using BEAMER_act
# *** First Block 						    :B_block:
#    :PROPERTIES:
#    :BEAMER_env: block
#    :END:
#    - this is visible from the beginning
# *** Second Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :BEAMER_act: <2->
#    :END:      
#    - and this one is revealed afterwards by using the BEAMER_act
#      keyword in the PROPERTIES section.
     
# ** Explicitely defining the transparancy of covered text
#    #+LATEX: \setbeamercovered{invisible}
# *** First Block 						    :B_block:
#    :PROPERTIES:
#    :BEAMER_env: block
#    :END:
#    - this is visible from the beginning
# *** Second Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :BEAMER_act: <2->
#    :END:      
#    - this is initially invisible since we used
#      =\setbeamercovered{invisible}= for this frame
#    - then it is revealed again using the BEAMER_act
#      keyword in the PROPERTIES section.
     
# ** different transparency setting and default overlay 
#    :PROPERTIES:
#    :BEAMER_act: [<+->]
#    :END:      

#    #+LATEX: \setbeamercovered{transparent=30}

# *** First Block 						    :B_block:
#    :PROPERTIES:
#    :BEAMER_env: block
#    :END:
#    this is visible from the beginning. Note that we specified another
#    transparency compared to the previous slide.
# *** Second Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :END:      
#    Initial visibility defined by =\setbeamercovered{transparent=30}=.
     
# *** Third Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :END:      
#    And a third block
     
# ** dynamic transparency setting and default overlay 
#    :PROPERTIES:
#    :BEAMER_act: [<+->]
#    :END:      

#    #+BEAMER: \setbeamercovered{highly dynamic}

# *** First Block 						    :B_block:
#    :PROPERTIES:
#    :BEAMER_env: block
#    :END:
#    this is visible from the beginning. We defined =\setbeamercovered{highly dynamic}=
#    so that other blocks are slowly getting less transparent.
# *** Second Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :END:      
#    a second block
     
# *** Third Block 					       :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :END:      
#    And a third block
     
# *** Fourth Block                                               :B_alertblock:
#    :PROPERTIES:
#    :BEAMER_env: alertblock
#    :END:      
#    And a fourth block

# ** plain text between two blocks
# *** block 1							    :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:
#     The first block
# *** ign							    :B_ignoreheading:
#     :PROPERTIES:
#     :BEAMER_env: ignoreheading
#     :END:
#     #+LATEX: \onslide<2-> A plain text paragraph. I only managed to get the right uncovering
#     behavior by using =#+LATEX: \onslide<2->= in front of the paragraph.
# *** block 2							    :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :BEAMER_act: <3->
#     :END:      
#     The second block
    

# * Multiple Columns
# ** Blocks in two columns

# *** A left block					      :B_block:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.45
#     :BEAMER_env: block
#     :END:
#     - this slide consists of two columns
#     - This is the first column

# *** A right block					      :B_block:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.45
#     :BEAMER_env: block
#     :END:
#     - this is the right column
      
# ** A text section and a figure

# *** A text section 						      :BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.4
#     :END:
#     - this slide consists of two columns
#     - the first (left) column has no heading and consists of text
#     - the second (right) column has an image and is enclosed in an
#       *example* block

# *** A screenshot 					    :BMCOL:B_example:
#     :PROPERTIES:
#     :BEAMER_col: 0.6
#     :BEAMER_env: example
#     :END:
#     #+ATTR_LaTeX: :width 1.0\textwidth :float t :placement [H]
#     [[file:fig/simplegraph1.png]]


# ** A centered text section and a figure

# *** A centered text section 					      :BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.4
#     :END:
# # #+LATEX: \vbox to .2\textheight{%
# # #+LATEX: \vfill
# #+LATEX: \vspace{0.2\textheight}
#     - a centered text section. I found no good way for
#       using =\vfill= or =\minipage= as referenced [[http://tex.stackexchange.com/questions/15244/why-does-vfill-not-work-inside-a-beamer-column][here]]

# # #+LATEX: \vfill
# # #+LATEX: }%

# *** A screenshot					    :B_example:BMCOL:
#     :PROPERTIES:
#     :BEAMER_col: 0.6
#     :BEAMER_env: example
#     :END:
#     #+ATTR_LaTeX: :width 1.0\textwidth :float t :placement [H]
#     [[file:fig/simplegraph1.png]]


# ** Babel
#    :PROPERTIES:
#    :BEAMER_envargs: [t]
#    :END:
# *** Octave code						      :BMCOL:B_block:
#     :PROPERTIES:
#     :BEAMER_col: 0.45
#     :BEAMER_env: block
#     :END:
# #+name: octaveexample
# #+begin_src octave :results output :exports both
# A = [1 2 ; 3 4]
# b = [1; 1];
# x = A\b
# #+end_src

# *** The output						      :BMCOL:B_block:
#     :PROPERTIES:
#     :BEAMER_col: 0.4
#     :BEAMER_env: block
#     :BEAMER_envargs: <2->
#     :END:

# #+results: octaveexample
# #+begin_example
# A =

#    1   2
#    3   4

# x =

#   -1
#    1

# #+end_example

# * Conclusions

# ** Summary
#    - org is an incredible tool for time management
#    - *but* it is also excellent for writing and for preparing presentations
#    - Beamer is a very powerful \LaTeX{} package for presentations
#    - the combination is unbeatable!


# * Appendix							 :B_appendix:
#   :PROPERTIES:
#   :BEAMER_env: appendix
#   :END:
# ** Appendix
#    :PROPERTIES:
#    :END:

#    SOME BACKUP SLIDES. The Appendix will not be listed in the table of contents.

# ** Backup slide 1
#    Some backup info
# ** Backup slide 2
#    These details are not part of the main talk.

# * COMMENT TODO
#   - show how to embed SVG pictures
    
# * COMMENT org babel settings
# Local variables:
# org-confirm-babel-evaluate: nil
# End:


